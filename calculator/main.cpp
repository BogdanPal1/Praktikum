/*
ID 63417695
Спринт 2. Задача "Калькулятор".
Палкин Богдан. Когорта 20.

-- ПРИНЦИП РАБОТЫ --
Для решения данной задачи был использован стек из
стандартной библиотеки шаблонов C++.

Алгоритм работы программы описан в самом задании:
"Для вычисления значения выражения, записанного в обратной польской нотации, 
 нужно считывать выражение слева направо и придерживаться следующих шагов:
    Обработка входного символа:
        1) Если на вход подан операнд, он помещается на вершину стека.
           Если на вход подан знак операции, то эта операция выполняется над 
           требуемым количеством значений, взятых из стека в порядке добавления. 
           Результат выполненной операции помещается на вершину стека.

        2) Если входной набор символов обработан не полностью, перейти к шагу 1.

        3) После полной обработки входного набора символов результат вычисления 
           выражения находится в вершине стека. Если в стеке осталось несколько 
           чисел, то надо вывести только верхний элемент."

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ -- 
Доказательство можно описать примером работы программы.

ПРИМЕР
"Посчитать значение выражения 3 4 +"

1) Программа считает первое значение;
2) Значение будет проверено на его принадлежность числам;
3) Так как значение число, то оно будет добавлено на вершину стека методом push;
4) После программа считает второе значение;
5) Снова будет проведена проверка на принадлежность значения числам;
6) Так как значение число, то оно будет добавлено на вершину стека методом push;
7) Программа считает следующее значение;
8) Так как следующее значение знак "+", то будет выполнена соответствующая
   данной операции ветвь:
   8а) С помощью метода top будет извлечено значение с вершины стека(4);
   8б) Будет выполнен метод pop, который удалит значение с вершины стека;
   8в) С помощью метода top будет извлечено значение с вершины стека(3);
   8г) Будет выполнен метод pop, который удалит значение с вершины стека;
   8д) С помощью метода push в стек будет добавлена сумма элементов 4 и 3;
9) Так как значения для считывания закончились программа выведет результат
   последней операции, который хранится на вершине стека. Для этого результат
   будет взят с вершины методом top.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Добавление элемента в стек и извлечение элемента из вершины выполняется за О(1).
Стоимость арифметических операций также можно принять равным О(1).
Но так как программе необходимо последовательно считывать операнды и операторы,
полное время работы будет зависеть от количества символов, которые необходимо считать.
Таким образом временная сложность будет соответствовать О(n), где n - количество
символов, подаваемых на вход.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Количество памяти зависит от количества считанных на данный момент операндов.
Если принять это количество за n, то количество необходимой памяти О(n).
*/

#include <iostream>
#include <stack>
#include <cmath>

bool isNumber(const std::string& str)
{
    return str.find_first_of("0123456789") != std::string::npos;
}

int main()
{
    std::stack<int> numStack;
    std::string input;

    while (std::cin >> input)
    {
        if (isNumber(input))
        {
            numStack.push(std::stoi(input));
        }
        else if(input == "+")
        {
            int a = numStack.top();
            numStack.pop();
            int b = numStack.top();
            numStack.pop();
            numStack.push(a + b);
        }
        else if(input == "-")
        {
            int a = numStack.top();
            numStack.pop();
            int b = numStack.top();
            numStack.pop();
            numStack.push(b - a);
        }
        else if(input == "*")
        {
            int a = numStack.top();
            numStack.pop();
            int b = numStack.top();
            numStack.pop();
            numStack.push(a * b);
        }
        else if(input == "/")
        {
            int a = numStack.top();
            numStack.pop();
            int b = numStack.top();
            numStack.pop();
            numStack.push(std::floor(b / static_cast<double>(a)));
        }
    }
    std::cout << numStack.top() << '\n';
    return 0;
}
